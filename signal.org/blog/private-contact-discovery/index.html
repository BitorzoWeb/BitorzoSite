<!DOCTYPE html><html lang="en">
<!-- Mirrored from signal.org/blog/private-contact-discovery/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 27 Aug 2020 07:58:13 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content=""><meta name="author" content=""><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="../rss.xml" /><meta property="og:title" content="Technology preview: Private contact discovery for Signal" /><meta property="og:site_name" content="Signal Messenger" /><meta property="og:type" content="website" /><meta property="og:description" content="At Signal, we’ve been thinking about the difficulty of private contact discoveryfor a long time. We’ve been working on strategies to improve our current design, andtoday we’ve published a new private contact discovery service.Using this service, Signal clients will be able to efficiently and scal..." /><meta property="og:url" content="index.html" /><meta property="og:image" content="../../assets/og/og-image-ff2096df535eee499356de64b19fa8cebb9681ab1e78cca7330e7f8b8d5ec6d5.png" /><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@signalapp"><meta name="twitter:creator" content="@signalapp"><meta name="twitter:url" content="index.html"><meta name="twitter:title" content="Technology preview: Private contact discovery for Signal"><meta name="twitter:description" content="At Signal, we’ve been thinking about the difficulty of private contact discoveryfor a long time. We’ve been working on strategies to improve our current design, andtoday we’ve published a new private contact discovery service.Using this service, Signal clients will be able to efficiently and scal..."><title>Bitorzo -  Blog >> Technology preview: Private contact discovery for Signal</title><link rel="apple-touch-icon" sizes="57x57" href="../../assets/favicon/apple-icon-57x57-1e56b07703490ebba4713a0b5ea25a03ae8d86eabc4a961158edf5b46590fd3d.png"><link rel="apple-touch-icon" sizes="60x60" href="../../assets/favicon/apple-icon-60x60-e2db2d0761f2007f5d2b1f9594a5caa49705c1221ced2472a2e471e0c53ed3fa.png"><link rel="apple-touch-icon" sizes="72x72" href="../../assets/favicon/apple-icon-72x72-97b53da0f83cc83e78f550a175abc7655b655a4ff6f8969616ccf6a45431f823.png"><link rel="apple-touch-icon" sizes="76x76" href="../../assets/favicon/apple-icon-76x76-9f2b2add20d8060fab5bda1a4fc4dbc23330e56b6ce846dc71af34b643b44294.png"><link rel="apple-touch-icon" sizes="114x114" href="../../assets/favicon/apple-icon-114x114-f6319e407b9c5379fbb0753dbf272e8d3b24a0c2e107d3c971fa173f861580bc.png"><link rel="apple-touch-icon" sizes="120x120" href="../../assets/favicon/apple-icon-120x120-c98504fda21e8555d8c527f46d170b182630953915e3f35e6be58ad7c2ba2016.png"><link rel="apple-touch-icon" sizes="144x144" href="../../assets/favicon/apple-icon-144x144-6673d278a3a610c29c506b94db1c39dbaed7316a3daa8dfa84b115d9a17a3be1.png"><link rel="apple-touch-icon" sizes="152x152" href="../../assets/favicon/apple-icon-152x152-8d0419698314ff17820aa277bc5c56df4048fff96b89d021c5e3240c804c008d.png"><link rel="apple-touch-icon" sizes="180x180" href="../../assets/favicon/apple-icon-180x180-aa2761b8418076157d993fa209969b64f3ef435dcbefb20e7f9b4ad03e6e76bd.png"><link rel="icon" type="image/png" sizes="192x192" href="../../assets/favicon/android-icon-192x192-2ce7be93a7e75de13098e18298fcb8910772ec2e035cea23f3c2ad438ff8e504.png"><link rel="icon" type="image/png" sizes="32x32" href="../../assets/favicon/favicon-32x32-382989a29cc9004cc5b4b723098a5663f944b48d4694df252b89caa831fa205f.png"><link rel="icon" type="image/png" sizes="96x96" href="../../assets/favicon/favicon-96x96-aa38de7ff5098e6c9a3a41bd2424266d64b0200d347d682292c01a1d6d402660.png"><link rel="icon" type="image/png" sizes="16x16" href="../../assets/favicon/favicon-16x16-c6d9330e8b333a3ff4dd7d9ccbfccbb22265db57ba79fd8d3f9a31a90e7d4857.png"><link rel="preload" href="../../assets/inter/Inter-Regular-c342b1b7f7d19be1429fef29bf3af6d9e8c3e21aba846e082cdee1db8a530c83.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="../../assets/inter/Inter-Italic-950174d1f78a8493886d74efd89ca703e56203ea6c1564f7957180ba58048d1e.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="../../assets/inter/Inter-SemiBold-af44b8a232c6946b5d4ced0df202e29f1330f66a2587b581826fd561bda24fad.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="../../assets/inter/Inter-SemiBoldItalic-a4f92da5bf69f56806968b8f82b555434357608a5e9b9800fb42a2098d487980.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="../../assets/inter/Inter-ExtraBold-74e72c6bbb7844899343c4783be9b4510e32951636acde44d5b4725e2132ea03.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="../../assets/inter/Inter-ExtraBoldItalic-2abc7ab18591e33fbc6bfe6a6b367ad9ee5ecc5e4662ef4863600c5e786f02ea.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="../../assets/fa/fa-brands-400-67ca1abd107c1c587489a06adc41ed3221a1b77048be449a076a5e93c93d2b98.woff2" as="font" crossorigin="anonymous"><link rel="manifest" href="../../assets/favicon/manifest-afc52691d6d2cefdcc79152af8efdf7848d5226b0daf713c2d6699c504fb3a75.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="../../assets/favicon/ms-icon-144x144-c87fa9bc9f7648a5dc55c8bb767caa2c9f3ff5d13dbdce9eb82e75e14ebe41d9.png"><meta name="theme-color" content="#ffffff"><link type="text/css" rel="stylesheet" href="../../assets/vendor/bulma-0.8.0.min-ccf7949cbe2c285e72f3a5c936d8abba9270e77d27b2529804ff4738dda4944e.css"><link type="text/css" rel="stylesheet" href="../../assets/ultramarine-a2815d7f3b4eb64754a6287ee073927e86f19e7f564c4aa010d62e9279e6dc07.css"><link type="text/css" rel="stylesheet" href="../../assets/vendor/fontawesome-5.4.2-6f60fac69be091431742fa23593bfdade087209c0db2bbb369913a2a4e91c252.css"><body id="signal" class="index has-navbar-fixed-top"><nav class="navbar signal-navbar is-fixed-top" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a href="../../index.html#signal"> <img class="signal-logo" src="../../assets/header/logo-f7ef605fe417d5520d38d546b3b774b4261c75220b9904da4d8b2ffc19a761ff.png"/> </a> <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="signalNavbar"> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> </a></div><div id="signalNavbar" class="navbar-menu"><div class="navbar-end"> <a class="navbar-item get-signal" href="../../download/index.html">Get Bitorzo</a> <a class="navbar-item" href="https://support.signal.org/">Support</a> <a class="navbar-item" href="../index.html">Blog</a> <a class="navbar-item" href="../../docs/index.html">Developers</a> <a class="navbar-item" href="../../workworkwork/index.html">Careers</a> <a class="navbar-item" href="../../donate/index.html">Donate</a> <a class="navbar-item" href="https://twitter.com/signalapp" target="_blank"><i class="fab fa-twitter"></i></a> <a class="navbar-item" href="https://instagram.com/signal_app/" target="_blank"><i class="fab fa-instagram"></i></a></div></div></div></nav><section id="post" class="section post"><article><div class="container is-centered"><div class="blog-post-header columns is-centered"><div class="column is-7"> <img class="author" src="https://avatars.githubusercontent.com/moxie0"/><h1 class="has-text-centered semibold"> Technology preview: Private contact discovery for Signal</h1><p class="body2 has-text-centered has-text-grey"> <a href="https://github.com/moxie0">moxie0</a> on 26 Sep 2017</div></div><div class="blog-post-content columns is-centered"><div class="column is-7"><p>At Signal, we’ve been thinking about <a href="../contact-discovery/index.html">the difficulty of private contact discovery</a> for a long time. We’ve been working on strategies to improve our current design, and today we’ve <a href="https://github.com/signalapp/ContactDiscoveryService/">published a new private contact discovery service</a>.<p>Using this service, Signal clients will be able to efficiently and scalably determine whether the contacts in their address book are Signal users <strong>without revealing the contacts in their address book to the Signal service</strong>.<p><h2 id="background">Background</h2><p>Signal is social software. We don’t believe that privacy is about austerity, or that a culture of sharing and communication should mean that privacy is a thing of the past. We want to enable online social interactions that are rich and expressive in all the ways that people desire, while simultaneously ensuring that communication is only visible to its intended recipients.<p>This squares technology with intent: when someone shares a photo with their friends, their intent is to share it <em>with their friends</em>. Not the service operator, ad networks, hackers, or governments.<h2 id="social-software-needs-a-social-graph">Social software needs a social graph</h2><p>The building block of almost all social software is the social graph. For people to be able to use software like Signal, they have to know how to contact their friends and colleagues using Signal.<p>This raises two related concerns:<ol><li>Building a social graph isn’t easy. Social networks have value proportional to their size, so participants aren’t motivated to join new social networks which aren’t already large. Very few people want to install a communication app, open the compose screen for the first time, and be met by an empty list of who they can communicate with.<li>We don’t want the Signal service to have visibility into the social graph of Signal users. Signal is always aspiring to be as “zero knowledge” as possible, and having a durable record of every user’s friends and contacts on our servers would obviously not be privacy-preserving.</ol><p>Almost all social software has to deal with the first problem. Most solve it by leveraging an existing social graph, such as Facebook (“Sign in with Facebook”), but that means the social graph is “owned” by Facebook.<p>Instead, Signal began by using the social graph that already lives on everyone’s phones: the address book. Rather than a centralized social graph owned by someone else, the address book is distributed and user-owned. Additionally, having the social graph already on the device means that the Signal service doesn’t need to store a copy of it. Any time someone installs or reinstalls Signal, their social graph is already available locally.<h2 id="contact-discovery">Contact discovery</h2><p>In order to turn the address book on a device into a social graph for Signal, the Signal client needs to be able to determine which of the device’s contacts are Signal users. In other words, the client needs to ask the service “Here are all my contacts, which of them are Signal users?”<p>Since we don’t want the Signal service to know the contents of a client’s address book, this question needs to be asked in a privacy-preserving way.<p>Traditionally, in Signal that process has looked like:<ol><li>The client calculates the truncated SHA256 hash of each phone number in the device’s address book.<li>The client transmits those truncated hashes to the service.<li>The service does a lookup from a set of hashed registered users.<li>The service returns the intersection of registered users.</ol><p>The obvious problem with this method is that the hash of a user identifier can almost always be inverted. Regardless of whether the identifier is a phone number, a user name, or an email address, the “keyspace” of all possible identifiers is too small.<p>This method of contact discovery isn’t ideal because of these shortcomings, but at the very least the Signal service’s design does not depend on knowledge of a user’s social graph in order to function. This has meant that if you trust the Signal service to be running the <a href="https://github.com/signalapp/Signal-Server">published server source code</a>, then the Signal service has no durable knowledge of a user’s social graph if it is hacked or <a href="../../bigbrother/eastern-virginia-grand-jury/index.html">subpoenaed</a>.<h2 id="trust-but-verify">Trust but verify</h2><p>Of course, what if that’s not the source code that’s actually running? After all, we could surreptitiously modify the service to log users’ contact discovery requests. Even if <em>we</em> have no motive to do that, someone who hacks the Signal service could potentially modify the code so that it logs user contact discovery requests, or (although unlikely given present law) some government agency could show up and require us to change the service so that it logs contact discovery requests. More fundamentally for us, we simply don’t want people to have to trust us. That’s not what privacy is about.<p>Doing better is difficult. There are a <a href="../contact-discovery/index.html">range of options that don’t work</a>, like using bloom filters, encrypted bloom filters, sharded bloom filters, private information retrieval, or private set intersection. What if, instead, there were just a way for clients to verify that the code running on our servers was the code they wanted to be running on our servers, and not something that we or a third party had modified?<p>Modern Intel chips support a feature called <a href="https://software.intel.com/en-us/articles/innovative-technology-for-cpu-based-attestation-and-sealing">Software Guard Extensions</a> (SGX). SGX allows applications to provision a “secure enclave” that is isolated from the host operating system and kernel, similar to technologies like ARM’s TrustZone. SGX enclaves also support a feature called <em>remote attestation</em>. Remote attestation provides a cryptographic guarantee of the code that is running in a remote enclave over a network.<p>Originally designed for DRM applications, most SGX examples imagine an SGX enclave running on a client. This would allow a server to stream media content to a client enclave with the assurance that the client software requesting the media is the “authentic” software that will play the media only once, instead of custom software that reverse engineered the network API call and will publish the media as a torrent instead.<p>However, we can invert the traditional SGX relationship to run a secure enclave on the server. An SGX enclave on the server-side would enable a service to perform computations on encrypted client data <em>without learning the content of the data or the result of the computation</em>.<h2 id="sgx-contact-discovery">SGX contact discovery</h2><p>Private contact discovery using SGX is fairly simple at a high level:<ol><li>Run a contact discovery service in a secure SGX enclave.<li>Clients that wish to perform contact discovery negotiate a secure connection over the network all the way through the remote OS to the enclave.<li>Clients perform remote attestation to ensure that the code which is running in the enclave is the same as the expected published open source code.<li>Clients transmit the encrypted identifiers from their address book to the enclave.<li>The enclave looks up a client’s contacts in the set of all registered users and encrypts the results back to the client.</ol><p>Since the enclave attests to the software that’s running remotely, and since the remote server and OS have no visibility into the enclave, the service learns nothing about the contents of the client request. It’s almost as if the client is executing the query locally on the client device.<p>Unfortunately, doing private computation in an SGX enclave is more difficult than it may initially seem.<h2 id="building-a-secure-sgx-service">Building a secure SGX service</h2><p>An SGX enclave runs in <a href="http://eprint.iacr.org/2016/204.pdf">hardware-encrypted RAM</a>, which prevents the host OS from being able to see an enclave’s memory contents (such as the contact information a client transmits to the enclave). However, the host OS can still see <em>memory access patterns</em>, even if the OS can’t see the contents of the memory being accessed.<p>That presents a number of potentially fatal problems. For example, consider an enclave function that is written as follows:<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">findRegisteredUsers</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">registeredUsers</span><span class="o">,</span>
                                       <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">clientContacts</span><span class="o">)</span>
<span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">clientContact</span> <span class="o">:</span> <span class="n">clientContacts</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">registeredUsers</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">clientContact</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">clientContact</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>The above code iterates over the list of contacts a client submits and checks a local hash table of all registered users in order to determine whether each of the client’s contacts is a registered user or not.<p>Even with encrypted RAM, the server OS can learn enough from observing memory access patterns in this function to determine the plaintext values of the contacts the client transmitted!<p>Consider that the OS probably knows the layout of the hash table containing all registered users. This is because it can watch it being built (the enclave has to get the list of all registered users from the OS or some other untrusted source), and those values need to be able to change in real time (also provided by an untrusted source) as new users sign up. Even if the OS didn’t know the layout of the hash table, it would still be able to map it out by submitting its own requests to the enclave through the normal enclave interface and observing where the enclave reads into the hash table for those known values.<p>With that knowledge, the OS only has to watch which hash table memory addresses the enclave reads from when processing a client request.<p>It gets worse! The amount of encrypted RAM available to an enclave is limited to 128MB, which isn’t enough to store a large data set of registered users. SGX makes it possible to store the set of all registered users outside the enclave and access that memory from within the enclave, but then the OS <em>really</em> knows what the layout of the registered users hash table is, since they’re not even in encrypted RAM.<h2 id="oblivious-ram">Oblivious RAM</h2><p>Given the above example, it’s clear that standard solutions deployed inside an SGX enclave won’t be enough to provide meaningful protection for what we’re trying to build. This class of problems has been studied under the discipline of <a href="https://en.wikipedia.org/wiki/Oblivious_ram">Oblivious RAM</a> (ORAM). The objective of ORAM is to define a CPU&lt;-&gt;RAM interface, such that the RAM behaves like RAM by retrieving memory for the CPU, but the RAM learns nothing about the memory access pattern of the CPU.<p>There are some elegant generalized ORAM techniques, like <a href="https://eprint.iacr.org/2013/280.pdf">Path ORAM</a>, but unfortunately they don’t work well for this problem. Most perform best when applications have a relatively small number of keys that map to large values, whereas we have an extremely large number of keys and zero-sized values. The more complicated attempts to provide generalized ORAM for data sets like ours, such as Recursive Path ORAM, don’t scale very well and are difficult to build for concurrent access.<p>If we think about solutions specific to our problem, one possibility is simply to make things inefficient:<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">findRegisteredUsers</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">registeredUsers</span><span class="o">,</span>
                                       <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">clientContacts</span><span class="o">)</span>
<span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">clientContact</span> <span class="o">:</span> <span class="n">clientContacts</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">registeredUser</span> <span class="o">:</span> <span class="n">registeredUsers</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">registeredUser</span> <span class="o">==</span> <span class="n">clientContact</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">clientContact</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>This function still has problems, but it solves our initial concern by linearizing everything. Instead of a lookup into a hash table of all registered users, this code does a full linear scan across the entire data set of all registered users for every client contact submitted. By touching the entire memory space consistently for each client contact, the OS can’t learn anything from the access patterns. However, with a billion registered users, this would obviously be way too slow.<p>It’s possible to speed up by inverting the original approach instead:<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">findRegisteredUsers</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">registeredUsers</span><span class="o">,</span>
                                       <span class="n">Set</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">clientContacts</span><span class="o">)</span>
<span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">registeredUser</span> <span class="o">:</span> <span class="n">registeredUsers</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">clientContacts</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">registeredUser</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">registeredUser</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>This is much faster. The above code still iterates across the entire set of registered users, but it only does so once for the entire collection of submitted client contacts. By keeping one big linear scan over the registered user data set, access to unencrypted RAM remains “oblivious,” since the OS will simply see the enclave touch every item once for each contact discovery request.<p>The full linear scan is fairly high latency, but by batching many pending client requests together, it can be high throughput.<p>However, there are still problems. If the OS knew the content or the layout of the <code class="highlighter-rouge">clientContacts</code> hash table, this wouldn’t be oblivious.<h2 id="oblivious-hash-table-construction">Oblivious hash table construction</h2><p>The “normal” way to construct a hash table of client contacts would be:<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">constructClientContactsTable</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">clientContacts</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Set</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">clientContact</span> <span class="o">:</span> <span class="n">clientContacts</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">clientContact</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>The above code iterates over the list of client contacts that we receive in an encrypted request and puts them in a hash table.<p>Obviously, this won’t work, since it reveals to the OS which hash buckets contain elements (the hash table memory addresses that received writes) and which are empty (the hash table memory addresses that didn’t receive writes). As the <code class="highlighter-rouge">findRegisteredUsers</code> function iterates over the list of all registered users, the OS knows which registered user the enclave is checking (it’s in unencrypted memory), and can then observe whether the read into the <code class="highlighter-rouge">clientContacts</code> hash table references a memory address that it saw a write to during the <code class="highlighter-rouge">constructClientContactsTable</code> process.<p>However, if the <code class="highlighter-rouge">clientContacts</code> hash table could be constructed obliviously instead, we wouldn’t have to worry about non-oblivious accesses to it.<p>There are two primary ways that observers from outside the enclave can monitor memory access patterns: page faults and memory bus snooping. In the former, the OS causes every memory access to page fault, which reveals (only) the address of the page the memory address is in. That results in a 4KB level of memory access granularity the OS is able to observe. However, if someone were to physically attach an FPGA to the memory bus, they could observe memory access at the granularity of a cache line.<p>To make hash table construction oblivious, we start with a bucketed hash table that looks like this:<div class="highlighter-rouge"><pre class="highlight"><code> ________   ________         ________
|Bucket 0| |Bucket 1|  ...  |Bucket N|
 --------   --------         --------
|B01||B01| |B01||B01|       |B01||B01|
 ---  ---   ---  ---         ---  ---
|B02||B02| |B02||B02|       |B02||B02|
 ---  ---   ---  ---         ---  ---
|...||...| |...||...|       |...||...|
 ---  ---   ---  ---         ---  ---
|B64||B64| |B64||B64|       |B64||B64|
 ---  ---   ---  ---         ---  ---
</code></pre></div><p>Each logical “bucket” (Bucket 1, Bucket 2, …, Bucket N) of the hash table is composed of two cache lines (B1, B2, … B64), one for storing client queries and one for storing lookup results. In order to populate the hash table with all of the client contacts in the request batch, the enclave iterates over each cache line in the hash table:<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">requestCacheLine</span> <span class="o">:</span> <span class="n">requestCacheLines</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">clientContact</span> <span class="o">:</span> <span class="n">clientContacts</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getHashIndex</span><span class="o">(</span><span class="n">clientContact</span><span class="o">)</span> <span class="o">==</span> <span class="n">requestCacheLine</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">requestCacheLine</span><span class="o">[</span><span class="n">nextAvailable</span><span class="o">]</span> <span class="o">=</span> <span class="n">clientContact</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">requestCacheLine</span><span class="o">[</span><span class="n">dummySlot</span><span class="o">]</span> <span class="o">=</span> <span class="n">clientContact</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Rather than iterating over the client contacts and adding them to the appropriate place in the hash table, the above code iterates over every cache line, and then checks to see which client contacts should be stored there. If there are <code class="highlighter-rouge">N</code> total client contacts in the full request batch, each cache line in the hash table receives <code class="highlighter-rouge">N</code> writes during this process.<p>This is a very inefficient way to construct a hash table, but after the hash table is constructed, the OS is left with no knowledge of what the hash table contains or how it is laid out. This means that it can be used just like a normal hash table in the critical path of the contact discovery lookup without revealing anything critical to observers.<h2 id="basic-recipe">Basic recipe</h2><p>There are many other concerns when building a secure enclave. Since <a href="https://arxiv.org/pdf/1611.06952.pdf">branches can potentially be observed</a> through memory access patterns, critical sections should not contain branches. Memory access patterns should always look the same for all outcomes, with care and attention similar to “constant time” programming considerations in cryptographic software.<p>Using the oblivious hash table construction method above, we can put together a general recipe for doing private contact discovery in SGX without leaking any information to parties that have control over the machine, even if they were to attach physical hardware to the memory bus:<ol><li>The contact discovery service passes a batch of encrypted contact discovery requests to the enclave.<li>The enclave decrypts the requests and uses the oblivious hash table construction process to build a hash table containing all submitted contacts.<li>The enclave iterates over the list of all registered users. For each registered user, the enclave indexes into the hash table containing the batch of client contacts and does a constant-time comparison against every contact in that cache line.<li>The enclave writes to the “results” cache line for that same hash index, regardless of whether there was a successful compare or not.<li>After iterating through the entire set of registered users, the enclave builds an oblivious response list for each client request in the batch.<li>The enclave encrypts the appropriate response list to each requesting client, and returns the batch results to the service.<li>The service transmits the encrypted response back to each requesting client.</ol><p>By pushing the inefficiencies into the setup and teardown sections of batch processing, the critical section remains fast enough for the entire process to scale to over a billion users.<h2 id="oblivious-limitations">Oblivious limitations</h2><p>The OS is still capable of learning minor things from careful observation. The hash table containing a batch of client contacts is composed of buckets that each contain space for 12 contacts. Using the oblivious hash table construction process, the OS does not know how many elements (if any) are in a bucket, or what those elements may be. However, the OS does know that there can’t be more than 12 contacts in a hash bucket.<p>As the enclave iterates across the set of all registered users while processing a batch, the OS might see the enclave index into the cache lines for a single bucket <em>more</em> than 12 times. If there were 13 users that correspond to the same hash index, the OS knows that it’s not possible for <em>all 13</em> of those users to have been in the client request, since they wouldn’t have fit into the hash bucket. However, the OS doesn’t learn whether any subset of them were or were not in the client request, which is the oblivious property that we desire.<h2 id="view-source">View source</h2><p>We’ve put all of this together into a full contact discovery service, scalable to billions of users, that allows Signal users to discover their social graph without revealing their contacts to the Signal service. Like everything we build, the <a href="https://github.com/signalapp/contactdiscoveryservice">contact discovery service is open source</a>.<p>The enclave code builds reproducibly, so anyone can verify that the published source code corresponds to the MRENCLAVE value of the remote enclave.<p>Check it out and let us know what you think! This is a beta technology preview, but we’ll be deploying the service into production and integrating it into clients as we finish testing over the next few months.<h2 id="acknowledgments">Acknowledgments</h2><p>Huge thanks to Jeff Griffin for doing the heavy lifting and writing all the enclave code, Henry Corrigan-Gibbs for introducing us to SGX, Raluca Ada Popa for explaining ORAM state of the art to us, and Nolan Leake for systems insight.<div class="social-sharing has-text-centered"><p>&nbsp;<p> <a href="https://twitter.com/intent/tweet?text=Technology%20preview:%20Private%20contact%20discovery%20for%20Signal&amp;url=https://signal.org/blog/private-contact-discovery/&amp;via=signalapp&amp;related=signalapp" title="Share on Twitter" target="_blank" class="btn btn-twitter"><i class="fab fa-twitter"></i> Tweet</a> <a href="https://facebook.com/sharer.php?u=https://signal.org/blog/private-contact-discovery/" rel="nofollow" title="Share on Facebook" target="_blank" class="btn btn-facebook"><i class="fab fa-facebook"></i> Facebook</a><h3 class="semibold">Want to get involved with Signal? <a href="../../workworkwork/index.html">We're hiring!</a></h3></div></div></div></div></article></section><footer class="footer"><div class="container"><div class="columns"><div class="column is-two-fifths is-hidden-mobile"> <span class="copyright">&copy; 2013&ndash;2020 Signal, a 501c3 nonprofit.</span><br /> Signal is a registered trademark in the United States and other countries.</div><div class="column"> <strong>Company</strong><ul><li> <a href="../../donate/index.html">Donate</a><li> <a href="../../workworkwork/index.html">Careers</a><li> <a href="../index.html">Blog</a><li> <a href="../../legal/index.html">Terms &amp; Privacy Policy</a></ul></div><div class="column"> <strong>Download</strong><ul><li> <a href="../../download/android/index.html">Android</a><li> <a href="../../download/ios/index.html">iPhone & iPad</a><li> <a href="../../download/windows/index.html">Windows</a><li> <a href="../../download/macos/index.html">Mac</a><li> <a href="../../download/linux/index.html">Linux</a></ul></div><div class="column"> <strong>Social</strong><ul><li> <a href="https://github.com/signalapp" target="_blank">Github</a><li> <a href="https://twitter.com/signalapp" target="_blank">Twitter</a><li> <a href="https://www.instagram.com/signal_app/" target="_blank">Instagram</a></ul></div><div class="column"> <strong>Help</strong><ul><li> <a href="https://support.signal.org/">Support</a><li> <a href="https://community.signalusers.org/">Community</a></ul></div><div class="column is-two-fifths is-hidden-tablet"> <span class="copyright">&copy; 2013&ndash;2020 Signal, a 501c3 nonprofit.</span><br /> Signal is a registered trademark in the United States and other countries.</div></div></div></footer><script type="text/javascript" src="../../assets/vendor/jquery-3.5.1.min-a6ed45d15e46615f8c15931ca254e398a912e770b10122a4435529a1a523180d.js"></script> <script type="text/javascript" src="../../assets/vendor/lottie-player-0.5.1.min-7b15c2adfdb246be3414fb8d6966f54c06cc82f090a5d23c77f079de4c16fef3.js"></script> <script type="text/javascript"> const $langSelectors = Array.prototype.slice.call(document.querySelectorAll('a[data-lang]')); $langSelectors.forEach((el) => { el.addEventListener('click', (ev) => { const lang = ev.getAttribute('data-lang'); if (lang) { document.cookie = 'selected_language=' + lang + '; samesite; secure; path=/; max-age=7776000;'; } }); }); document.addEventListener('DOMContentLoaded', () => { var userAgent = navigator.userAgent.toLowerCase(); var isIOS = ( userAgent.indexOf('iphone') !== -1 || userAgent.indexOf('ipad') !== -1 || userAgent.indexOf('ipod') !== -1 ); var isAndroid = userAgent.indexOf('android') !== -1; var $downloadSignal = $('.get-signal'); if (isIOS || isAndroid) { var url = isIOS ? 'https://apps.apple.com/us/app/signal-private-messenger/id874139669' : 'https://play.google.com/store/apps/details?id=org.thoughtcrime.securesms'; $downloadSignal.prop('href', url); $downloadSignal.html('<span>Get Bitorzo</span> <i class="fas fa-external-link-alt"></i>'); } const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger')); if ($navbarBurgers.length > 0) { $navbarBurgers.forEach((el) => { el.addEventListener('click', () => { const target = el.dataset.target; const $target = document.getElementById(target); el.classList.toggle('is-active'); $target.classList.toggle('is-active'); }); }); } }); </script> <script type="text/javascript"> var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101071404); (function() { var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'http://static.getclicky.com/js'; ( document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0] ).appendChild( s ); })(); </script> <noscript><p><img width="1" height="1" src="../../../in.getclicky.com/101071404ns.gif" /></noscript>
